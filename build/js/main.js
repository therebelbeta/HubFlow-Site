var App=angular.module("hubflow",["ngRoute","templates"]);App.config(["$routeProvider",function(e){e.when("/",{templateUrl:"states/intro.html"}).when("/gitflow",{templateUrl:"states/introducinggitflow.html"}).when("/hubflow",{templateUrl:"states/hubflowtools.html"}).when("/gitflowwithgithub",{templateUrl:"states/gitflowwithgithub.html"}).when("/versioning",{templateUrl:"states/versioning.html"}).when("/examples",{templateUrl:"states/examples.html"}).when("/changelog",{templateUrl:"states/changelog.html"}).otherwise({redirectTo:"/"})}]),angular.module("templates",[]).run(["$templateCache",function(e){e.put("states/changelog.html",'<div class="maincontent"><div class="nextbar nextbar-top"><ul class="nav nav-pills"><li class="prev"><a href="#/examples">Prev: Examples</a></li><li class="next"><a href="#/">Back to: HubFlow: GitFlow For GitHub</a></li></ul></div><h1 id="changelog">ChangeLog</h1><h2 id="v152__29th_july_2013">v1.5.2 - 29th July 2013</h2><p>This release is a bug-fix release.</p><h3 id="fixes">Fixes:</h3><ul><li><strong>git hf feature start</strong>: set up the remote tracking branch correctly</li><li><strong>git hf update</strong>: go back to branch we started on after updating all the branches</li></ul><h2 id="v151__24th_march_2013">v1.5.1 - 24th March 2013</h2><p>So many people turned out to be using v1.5.0 straight from the develop branch that it seemed best to bump the version to v1.5.1 before final release. Thank you to everyone for the feedback - keep it coming!</p><h3 id="new">New:</h3><ul><li><strong>install.sh</strong>: now supports INSTALL_INTO environment variable if you want to change the install location (the default is /usr/local/bin)</li><li><strong>git hf pull</strong>: bring down and merge changes from the remote master, develop and current branches</li><li><strong>git hf push</strong>: a more generic (and long-term) replacement for the ‘feature publish’ et al commands</li><li><strong>git hf feature push -F</strong>: new –force feature which <em>will</em> overwrite origin’s copy of the branch with your copy (thanks to <a href="https://github.com/bsedat">bsedat</a> for the patch)</li><li><strong>git hf update</strong>: new –no-prune flag to disable ‘git fetch –prune’</li></ul><h3 id="fixed">Fixed:</h3><ul><li><strong>install.sh</strong> does not require sudo/root if target folder is writeable (thanks to <a href="https://github.com/mborsuk">mborsuk</a> for the patch) - might help folks trying to install using Cygwin</li><li><strong>git hf init</strong>: if this command creates the ‘develop’ branch, it now pushes that branch back up to origin automatically</li><li><strong>git hf hotfix start</strong>: fetches latest refs from origin before attempting sanity checks; should keep things more consistent</li><li><strong>git hf release start</strong>: fetches latest refs from origin before attempting sanity checks; should keep things more consistent</li><li><strong>git hf feature cancel</strong>: deletes the local branch even if it contains unmerged changes (thanks to <a href="https://github.com/mheap">mheap</a> for the patch)</li><li><strong>git hf feature finish</strong>: pull down latest changes from origin; avoids manual ‘git hf update’ first</li><li><strong>git hf feature finish</strong>: clearer message when a feature has not yet been merged via a GitHub pull request</li><li><strong>git hf feature submit</strong>: now supports the VISUAL and EDITOR environment variables (thanks to <a href="https://github.com/mbrace">mbrace</a> for the patch)</li><li><strong>git hf release finish</strong>: pull down latest changes from origin; avoids manual ‘git hf update’ first</li><li><strong>git hf hotfix finish</strong>: pull down latest changes from origin; avoids manual ‘git hf update’ first</li><li><strong>git hf (feature|hotfix|release) start</strong>: refactored to increase amount of shared code</li><li><strong>git hf update</strong>: does not switch to master or develop branch if there are no changes to merge in (speed improvement!)</li><li><strong>git hf update</strong>: does not push to origin if there are no changes to merge in (speed improvement!)</li><li><strong>merge conflicts</strong>: refactored to simplify, standardise the behaviour across all commands</li><li><strong>co-existing with gitflow</strong>: you can now install the original gitflow tools and the hubflow tools alongside each other with no file conflicts</li><li>various portability improvements for OS X (thanks to <a href="https://github.com/mbrace">mbrace</a> for the patches)</li><li><strong>Improved README</strong> file (thanks to <a href="https://github.com/j0k3r">j0k3r</a> for the patch)</li><li><strong>Fixed the <a href="http://datasift.github.com/gitflow/GitFlowForGitHub.html#the_poster">poster</a></strong> to recommend the new commands added in v1.5</li></ul><h3 id="dropped">Dropped:</h3><p>We’ve removed the following features, as they don’t fit into our core idea of Hubflow as a workflow that is focused on interacting primarily with GitHub:</p><ul><li><strong>git hf feature pull</strong>: is now an alias for <code>git hf pull</code></li><li><strong>git hf feature push</strong>: is now an alias for <code>git hf push</code></li><li><strong>git hf feature track</strong>: command deleted</li><li><strong>git hf hotfix pull</strong>: is now an alias for <code>git hf pull</code></li><li><strong>git hf hotfix push</strong>: is now an alias for <code>git hf push</code></li><li><strong>git hf hotfix track</strong>: command deleted</li><li><strong>git hf release pull</strong>: is now an alias for <code>git hf pull</code></li><li><strong>git hf release push</strong>: is now an alias for <code>git hf push</code></li><li><strong>git hf release track</strong>: command deleted</li></ul><h2 id="v142__19th_february_2013">v1.4.2 - 19th February 2013</h2><h3 id="fixed">Fixed:</h3><ul><li><strong>git hf release pull</strong> should now work (was incomplete) (thanks to neonal)</li><li><strong>git hf release push</strong> should now work (was incomplete) (thanks to neonal)</li><li>Bug fix for incompatibility with Git v1.7.10.2 (Apple Git-33)</li></ul><h2 id="v141__12th_october_2012">v1.4.1 - 12th October 2012</h2><h3 id="fixed">Fixed:</h3><ul><li><strong>git hf init</strong> now creates a <strong>master</strong> branch if the repo currently does not have one</li></ul><h2 id="v140__3rd_october_2012">v1.4.0 - 3rd October 2012</h2><h3 id="new">New:</h3><ul><li><strong>git hf hotfix cancel</strong>: deletes a hotfix branch that is in progress.</li><li><strong>git hf feature cancel</strong>: deletes a feature branch that is in progress.</li><li><strong>git hf feature finish</strong> will abort if the feature hasn’t yet been merged via a pull request. You can override this using the -f (force) flag.</li></ul><h3 id="fixed">Fixed:</h3><ul><li><strong>git hf hotfix finish</strong> now deletes the remote hotfix branch first, to avoid warnings about partially merged branches.</li><li><strong>git hf feature pull</strong> is now as verbose as all of the other commands, so that you can see what is happening</li><li><strong>git hf feature pull</strong> now dies correctly if there’s a problem talking to GitHub</li><li><strong>git hf release cancel</strong> no longer merges into the <strong>develop</strong> branch by default.</li></ul><h3 id="removed">Removed:</h3><ul><li><strong>git hf feature publish</strong>: not needed, use <em>git hf feature push</em> instead.</li></ul><div class="nextbar nextbar-bottom"><ul class="nav nav-pills"><li class="prev"><a href="#/examples">Prev: Examples</a></li><li class="next"><a href="#/">Back to: HubFlow: GitFlow For GitHub</a></li></ul></div></div>'),e.put("states/examples.html",'<div class="maincontent"><div class="nextbar nextbar-top"><ul class="nav nav-pills"><li class="prev"><a href="#/versioning">Prev: Versioning</a></li><li class="next"><a href="#/changelog">Next: ChangeLog</a></li></ul></div><h1 id="examples">Examples</h1><h2 id="introduction">Introduction</h2><p>To finish off our explaination of using GitFlow with GitHub, we’ve got some examples of different builds of software.</p><h2 id="questions">Questions</h2><p>In the following examples, can you say …</p><ul><li>what the version number change means?</li><li>if the change breaks backwards-compatibility or not?</li><li>which branch or branches the build may have come from?</li><li>which kinds of environments the build can be installed into?</li></ul><p>Here are the example version numbers:</p><ol><li>foobar-1.0.0-SNAPSHOT20120512</li><li>foobar-1.0.0-SNAPSHOT20120512</li><li>foobar-1.0.0 -&gt; foobar-1.0.1</li><li>foobar-1.0.1 -&gt; foobar-1.0.2-rc1</li><li>foobar-1.0.2 -&gt; foobar-1.1.0-rc1</li><li>foobar-1.2.0 -&gt; foobar-2.0.0</li></ol><h2 id="answers">Answers</h2><p><strong>foobar-1.0.0-SNAPSHOT20120512</strong>:</p><ul><li>This is a development snapshot</li><li>It might break backwards compatibility</li><li>It will have been built from a feature branch, or from the develop branch</li><li>It can be installed on dev boxes and integration environments.</li></ul><p><strong>foobar-1.0.0 -&gt; foobar-1.0.1</strong>:</p><ul><li>This is a bugfix release</li><li>It does not break backwards compatibility</li><li>It will have been built from the master branch</li><li>It can be installed everywhere</li></ul><p><strong>foobar-1.0.1 -&gt; foobar-1.0.2-rc1</strong>:</p><ul><li>This is a bugfix release candidate</li><li>It does not break backwards compatibility</li><li>It will have been built from the hotfix branch called hotfix/1.0.1</li><li>It can be installed everywhere except production</li></ul><p><strong>foobar-1.0.2 -&gt; foobar-1.1.0-rc1</strong>:</p><ul><li>This is a release candidate for a minor release</li><li>It does not break backwards compatibility</li><li>It will contain new features</li><li>It may also contain bugfixes</li><li>It will have been built from the release branch called release/1.1.0</li><li>It can be installed everywhere except production</li></ul><p><strong>foobar-1.2.0 -&gt; foobar-2.0.0</strong>:</p><ul><li>This is a major new release</li><li>It may break backwards compatibility</li><li>It will have been built from the master branch</li><li>It can be installed everywhere</li></ul><div class="nextbar nextbar-bottom"><ul class="nav nav-pills"><li class="prev"><a href="#/versioning">Prev: Versioning</a></li><li class="next"><a href="#/changelog">Next: ChangeLog</a></li></ul></div></div>'),e.put("states/gitflowwithgithub.html",'<div class="maincontent"><div class="nextbar nextbar-top"><ul class="nav nav-pills"><li class="prev"><a href="#/hubflow">Prev: HubFlow: The GitFlow Tools Adapted For GitHub</a></li><li class="next"><a href="#/versioning">Next: Versioning</a></li></ul></div><h1 id="using_gitflow_with_github">Using GitFlow With GitHub</h1><h2 id="introduction">Introduction</h2><p>This is our recommended workflow for using:</p><ul><li><a href="http://nvie.com/posts/a-successful-git-branching-model/">The GitFlow branching model</a></li><li>+<a href="https://github.com/datasift/gitflow">HubFlow, our fork of the GitFlow tools</a></li><li>+<a href="https://github.com/">GitHub</a></li></ul><p>together. We’re assuming you’ve already looked at stock GitFlow, and understand the concepts of <strong>feature branches</strong>, <strong>release branches</strong>, <strong>hotfixes</strong>, <strong>releases</strong> and the <strong>develop branch</strong>. If you haven’t, please first read:</p><ul><li><a href="http://nvie.com/posts/a-successful-git-branching-model/">GitFlow</a> (Vincent Driessen’s original blog post)</li><li><a href="http://datasift.github.com/gitflow/IntroducingGitFlow.html">Introducing GitFlow</a> (our own introduction to GitFlow)</li></ul><h2 id="the_poster">The Poster</h2><p><img alt="GitFlow For GitHub" src="img/GitFlowWorkflowNoFork.png"></p><p><a href="http://datasift.github.io/gitflow/GitFlowWorkflowNoFork.svg">Original SVG file</a>. Created in Inkscape.</p><p><span class="label label-info">The key points are:</span></p><ul><li>Don’t fork repos on GitHub - clone the master repo directly</li><li>Push feature branches back to origin repo so others can collaborate</li><li>Use the GitHub website to create pull requests from feature branches</li><li>Don’t accept your own pull requests!</li></ul><h2 id="1_cloning_a_repo">1. Cloning A Repo</h2><p>Clone the existing repo from GitHub to your local workstation:</p><div class="highlight"><pre><code class="bash">git clone git@github.com:##orgname##/##reponame##</code></pre></div><p><span class="label label-important">Please remember:</span></p><ul><li>Do not fork the repo on GitHub - clone the master repo directly.</li></ul><h2 id="2_initialise_the_hubflow_tools">2. Initialise The HubFlow Tools</h2><p>The HubFlow tools need to be initialised before they can be used:</p><div class="highlight"><pre><code class="bash"><span class="nb">cd</span> <span class="c">##reponame##</span> git hf init</code></pre></div><p><span class="label label-important">Please remember:</span></p><ul><li>You have to do this every time you clone a repo.</li></ul><h2 id="3_create_a_feature_branch">3. Create A Feature Branch</h2><p>If you are creating a new feature branch, do this:</p><div class="highlight"><pre><code class="bash">git hf feature start <span class="c">##feature-name##</span></code></pre></div><p>If you are starting to work on an existing feature branch, do this:</p><div class="highlight"><pre><code class="bash">git hf feature checkout <span class="c">##feature-name##</span></code></pre></div><p><span class="label label-important">Please remember:</span></p><ul><li>All new work (new features, non-emergency bug fixes)<strong>must</strong> be done in a new feature branch.</li><li>Give your feature branches sensible names. If you’re working on a ticket, use the ticket number as the feature branch name (e.g. ticket-1234).</li><li>If the feature branch already exists on the master repo, this command will fail with an error.</li></ul><h2 id="4_publish_the_feature_branch_on_github">4. Publish The Feature Branch On GitHub</h2><p>Push your feature branch back to GitHub as you make progress on your changes:</p><div class="highlight"><pre><code class="bash">git hf push</code></pre></div><h2 id="5_keep_up_to_date">5. Keep Up To Date</h2><p>You’ll need to bring down completed features &amp; hotfixes from other developers, and merge them into your feature branch regularly. (Once a day, first thing in the morning, is a good rule of thumb).</p><div class="highlight"><pre><code class="bash"><span class="c"># if you\'re not on your feature branch</span> <br>git hf feature checkout <span class="c">##feature-name##</span> <br><span class="c"># pull down master and develop branches</span> <br>git hf update <br><span class="c"># merge develop into your feature branch</span> <br>git merge develop <br></code></pre></div><h2 id="6_collaborate_with_others">6. Collaborate With Others</h2><p>Push your feature branch back to GitHub whenever you need to share your changes with colleagues:</p><div class="highlight"><pre><code class="bash">git hf push</code></pre></div><p>Pull your colleague’s changes back to your local clone:</p><div class="highlight"><pre><code class="bash">git hf pull</code></pre></div><h2 id="7_merge_your_feature_into_develop_branch">7. Merge Your Feature Into Develop Branch</h2><div class="highlight"><pre><code class="bash">git hf push</code></pre></div><p>Then, use the GitHub website to create a pull request to ##reponame##/develop branch from ##reponame##/feature/##feature-name##.</p><p><img alt="Pull Request" src="img/PullRequest1.png"></p><p><img alt="Pull Request" src="img/PullRequest2.png"></p><p><img alt="Pull Request" src="img/PullRequest3.png"></p><p><img alt="Pull Request" src="img/PullRequest4.png"></p><p><img alt="Pull Request" src="img/PullRequest5.png"></p><p>Ask a colleague to review your pull-request; don’t accept it yourself unless you have to. Once the pull request has been accepted, close your feature using the HubFlow tools:</p><div class="highlight"><pre><code class="bash">git hf feature finish</code></pre></div><h2 id="8_creating_releases">8. Creating Releases</h2><p>When you have enough completed features, create a release branch:</p><div class="highlight"><pre><code class="bash">git hf update\n      git hf release start <span class="c">##version-number##</span></code></pre></div><p>Release branches are given version numbers for name. For example:</p><div class="highlight"><pre><code class="bash">git hf release start 2.6.0</code></pre></div><p>creates the branch <strong>release/2.6.0</strong>.</p><p>Once you’ve created the release branch, <strong>remember to update the version number in your code</strong> (in the pom.xml, Makefile, build.xml or wherever it is stored).</p><p>Build the code, deploy it into test environments, find bugs. Fix the bugs directly inside the release branch. Keep building, deploying, debugging, fixing until you’re happy that the release is ready.</p><p>When you’re ready to tag the release and merge it back into master and develop branches, do this:</p><div class="highlight"><pre><code class="bash">git hf release finish <span class="c">##version-number##</span></code></pre></div><p>This closes the release branch and creates a tag called <strong>##version-number##</strong> against the <strong>master branch</strong>.</p><h2 id="9_creating_hotfixes">9. Creating Hotfixes</h2><p>A hotfix (not shown on the diagram at the top of this page) is a special kind of release. Unlike features and releases (which are branched from <strong>develop</strong> ), hotfixes are branched from <strong>master</strong>. Use hotfixes when you want to make and release an urgent change to your latest released code, and you don’t want the changes currently in <strong>develop</strong> to ship yet.</p><p>To create a new hotfix:</p><div class="highlight"><pre><code class="bash">git hf update\n      git hf hotfix start <span class="c">##version-number##</span></code></pre></div><p>This creates a new branch called <strong>hotfix/##version-number##</strong>, off of the latest <strong>master</strong> branch.</p><p>Once you’ve created the hotfix branch, <strong>remember to update the version number in your code</strong> (in the pom.xml, Makefile, build.xml or wherever it is stored).</p><p>Edit the code, build it, deploy it into test environments, make sure that your hotfix works. Keep editing, building, deploying, debugging and fixing until you’re happy that the hotfix is ready. Remember that you can use the <em>git merge</em> command if you need to merge changes from a feature branch into the hotfix that you are preparing.</p><p>When you’re ready to tag the hotfix and merge it back into master and develop branches, do this:</p><div class="highlight"><pre><code class="bash">git hf hotfix finish <span class="c">##version-number##</span></code></pre></div><p>This closes the hotfix branch and creates a tag called <strong>##version-number##</strong> against the <strong>master branch</strong>.</p><p><span class="label label-important">Be careful with hotfixes:</span></p><p>You can use <em>git hf hotfix start ##version-number## ##older-tag##</em> to create a hotfix off of an older tag. However, if you look back at <a href="http://nvie.com/img/2009/12/Screen-shot-2009-12-24-at-11.32.03.png">Vincent’s original diagram</a>, notice how changes happen in <strong>time</strong> order. When you finish this kind of hotfix, it gets merged back into the latest <strong>master</strong> branch; it does not get merged into just after the tag that you branched off. This can cause problems, such as <strong>master</strong> ending up with the wrong version number, which you will have to spot and fix by hand for now.</p><div class="nextbar nextbar-bottom"><ul class="nav nav-pills"><li class="prev"><a href="#/hubflow">Prev: HubFlow: The GitFlow Tools Adapted For GitHub</a></li><li class="next"><a href="#/versioning">Next: Versioning</a></li></ul></div></div>'),e.put("states/hubflowtools.html",'<div class="maincontent"><div class="nextbar nextbar-top"><ul class="nav nav-pills"><li class="prev"><a href="#/gitflow">Prev: Introducing GitFlow</a></li><li class="next"><a href="#/gitflowwithgithub">Next: Using GitFlow With GitHub</a></li></ul></div><h1 id="hubflow_the_gitflow_tools_adapted_for_github">HubFlow: The GitFlow Tools Adapted For GitHub</h1><h2 id="introduction">Introduction</h2><p>If you look at <a href="http://nvie.com/posts/a-successful-git-branching-model/">Vincent’s original blog post</a>, he’s listed all of the individual Git commands that you need to use to create all of the different branches in the GitFlow model. They’re all standard Git commands … and if you’re also still getting your head around Git (and still learning why it is different to centralised source control systems like Subversion, or replicated source control systems like Mercurial), it adds to what is already quite a steep learning curve.</p><p>Vincent created an extension for Git, called <a href="https://github.com/nvie/gitflow">GitFlow</a>, which turns most of the steps you need to do into one-line commands. A company called DataFlow wanted it to work better with GitHub, so to reduce confusion with the original GitFlow tools, they decided to maintain their own fork of the GitFlow tools called <strong>HubFlow</strong>.</p><h2 id="what_is_hubflow">What Is HubFlow?</h2><p><a href="https://github.com/datasift/gitflow">HubFlow</a> is:</p><ul><li>an extension to the Git command-line tools</li><li>a fork of the original <a href="https://github.com/nvie/gitflow">GitFlow tools</a></li><li>one-line commands for using the <a href="#/gitflow">GitFlow branching model</a> with GitHub</li><li>focused on making it as easy as possible to use GitFlow with GitHub</li></ul><p>The main differences between the original GitFlow tools and HubFlow are:</p><ul><li>by default, commands push to / pull from GitHub wherever it is appropriate</li><li>we’ve added additional commands (such as <strong>feature push</strong> and <strong>feature pull</strong> ) to fill in some gaps in the original GitFlow tools</li></ul><h2 id="installing_hubflow">Installing HubFlow</h2><p>Installing the HubFlow tools for the first time is very easy:</p><div class="highlight"><pre><code class="bash">git clone https://github.com/datasift/gitflow <span class="nb">cd</span> gitflow\n      sudo ./install.sh</code></pre></div><h2 id="upgrading_hubflow">Upgrading HubFlow</h2><p>If you want to upgrade to the latest version of HubFlow, simply run:</p><div class="highlight"><pre><code class="bash">sudo git hf upgrade</code></pre></div><h2 id="listing_the_available_commands">Listing The Available Commands</h2><p>To see all of the commands that HubFlow provides, simply run:</p><div class="highlight"><pre><code class="bash">git hf <span class="nb">help</span></code></pre></div><p>All of the HubFlow commands start with <strong>git hf</strong>, to distinguish them from the original GitFlow commands.</p><div class="nextbar nextbar-bottom"><ul class="nav nav-pills"><li class="prev"><a href="#/gitflow">Prev: Introducing GitFlow</a></li><li class="next"><a href="#/gitflowwithgithub">Next: Using GitFlow With GitHub</a></li></ul></div></div>'),e.put("states/intro.html",'<div class="maincontent"><div class="nextbar nextbar-top"><ul class="nav nav-pills"><li class="prev">&nbsp;</li><li class="next"><a href="#/gitflow">Next: Introducing GitFlow</a></li></ul></div><h1 id="hubflow_gitflow_for_github">GitFlow &amp; Semantic Versioning</h1><h2 id="what_we_cover">What We Cover</h2><p>On this site, you’ll find:</p><ul><li><strong><a href="#/gitflow">Introducing GitFlow</a></strong>: A brief overview of what Gitflow is. If you’re learning about GitFlow for the first time, you should also read <a href="http://nvie.com/posts/a-successful-git-branching-model/">Vincent Driessen’s original blog post introducing GitFlow</a>.</li><li><strong><a href="#/hubflow">The HubFlow Tools</a></strong>: this is an introduction to the GitHub-focused fork of the <a href="https://github.com/nvie/gitflow">GitFlow extension for git</a>, which is called <strong>HubFlow</strong> to avoid any confusion with the original GitFlow extension commands. Includes installation instructions and how to contribute patches back.</li><li><strong><a href="#/gitflowwithgithub">Using GitFlow With GitHub</a></strong>: this is probably the page you’re really looking for. It explains how to apply the GitFlow branching model if you’re using GitHub for hosting, and includes all the commands you need for each of the common tasks you’ll do.</li><li><strong><a href="#/versioning">Versioning</a></strong>: to finish off, we look at why version numbers matter, and how you should use them in your projects.</li></ul><p>We hope you find this useful, and time-saving.</p><h2 id="licence">Licence</h2><p>This site is based off the original by DataSift, and just like Vincent’s original GitFlow post, every page on this website is published under the <a href="http://creativecommons.org/licenses/by-sa/3.0/nl/deed.en_GB">Creative Commons CC BY-SA</a> licence, and DataSift\'s <strong>HubFlow</strong> fork of the GitFlow tools is licenced under the <a href="https://github.com/datasift/gitflow/blob/develop/LICENSE">BSD 2-Clause Licence</a>.</p><p>You’ll find the source code for this website in the <a href="https://github.com/datasift/gitflow/tree/gh-pages">gh-pages branch of DataSift\'s gitflow repo on GitHub</a>.</p></div>'),e.put("states/introducinggitflow.html",'<div class="maincontent"><div class="nextbar nextbar-top"><ul class="nav nav-pills"><li class="prev"><a href="#/">Prev: HubFlow: GitFlow For GitHub</a></li><li class="next"><a href="#/hubflow">Next: HubFlow: The GitFlow Tools Adapted For GitHub</a></li></ul></div><h1 id="introducing_gitflow">Introducing GitFlow</h1><h2 id="what_is_gitflow">What Is GitFlow?</h2><p><a href="http://nvie.com/posts/a-successful-git-branching-model/">GitFlow</a> is a branching model for Git, created by Vincent Driessen. It has attracted a lot of attention because it is very well suited to collaboration and scaling the development team.</p><p><img alt="GitFlow" src="img/Screen-shot-2009-12-24-at-11.32.03.png"></p><h2 id="key_benefits">Key Benefits</h2><h3 id="parallel_development">Parallel Development</h3><p>One of the great things about GitFlow is that it makes parallel development very easy, by isolating new development from finished work. New development (such as features and non-emergency bug fixes) is done in <strong>feature branches</strong>, and is only merged back into main body of code when the developer(s) is happy that the code is ready for release.</p><p>Although interruptions are a BadThing(tm), if you are asked to switch from one task to another, all you need to do is commit your changes and then create a new feature branch for your new task. When that task is done, just checkout your original feature branch and you can continue where you left off.</p><h3 id="collaboration">Collaboration</h3><p>Feature branches also make it easier for two or more developers to collaborate on the same feature, because each feature branch is a sandbox where the only changes are the changes necessary to get the new feature working. That makes it very easy to see and follow what each collaborator is doing.</p><h3 id="release_staging_area">Release Staging Area</h3><p>As new development is completed, it gets merged back into the <strong>develop branch</strong>, which is a staging area for all completed features that haven’t yet been released. So when the next release is branched off of <strong>develop</strong>, it will automatically contain all of the new stuff that has been finished.</p><h3 id="support_for_emergency_fixes">Support For Emergency Fixes</h3><p>GitFlow supports <strong>hotfix branches</strong> - branches made from a tagged release. You can use these to make an emergency change, safe in the knowledge that the hotfix will only contain your emergency fix. There’s no risk that you’ll accidentally merge in new development at the same time.</p><h2 id="how_it_works">How It Works</h2><p>New development (new features, non-emergency bug fixes) are built in <strong>feature branches</strong>:</p><p><img alt="GitFlow feature branches" src="img/GitFlowFeatureBranches.png"></p><p>Feature branches are branched off of the <strong>develop branch</strong>, and finished features and fixes are merged back into the <strong>develop branch</strong> when they’re ready for release:</p><p><img alt="GitFlow develop branch" src="img/GitFlowDevelopBranch.png"></p><p>When it is time to make a release, a <strong>release branch</strong> is created off of <strong>develop</strong>:</p><p><img alt="GitFlow release branch" src="img/GitFlowReleaseBranch.png"></p><p>The code in the <strong>release branch</strong> is deployed onto a suitable test environment, tested, and any problems are fixed directly in the release branch. This <strong>deploy -&gt; test -&gt; fix -&gt; redeploy -&gt; retest</strong> cycle continues until you’re happy that the release is good enough to release to customers.</p><p>When the release is finished, the <strong>release branch</strong> is merged into <strong>master</strong> <strong>and</strong> into <strong>develop</strong> too, to make sure that any changes made in the <strong>release branch</strong> aren’t accidentally lost by new development.</p><p><img alt="GitFlow master branch" src="img/GitFlowMasterBranch.png"></p><p>The <strong>master branch</strong> tracks released code only. The only commits to <strong>master</strong> are merges from <strong>release branches</strong> and <strong>hotfix branches</strong>.</p><p><strong>Hotfix branches</strong> are used to create emergency fixes:</p><p><img alt="GitFlow hotfix branch" src="img/GitFlowHotfixBranch.png"></p><p>They are branched directly from a tagged release in the <strong>master branch</strong>, and when finished are merged back into both <strong>master</strong> and <strong>develop</strong> to make sure that the hotfix isn’t accidentally lost when the next regular release occurs.</p><div class="nextbar nextbar-bottom"><ul class="nav nav-pills"><li class="prev"><a href="#/">Prev: HubFlow: GitFlow For GitHub</a></li><li class="next"><a href="#/hubflow">Next: HubFlow: The GitFlow Tools Adapted For GitHub</a></li></ul></div></div>'),e.put("states/versioning.html",'<div class="maincontent"><div class="nextbar nextbar-top"><ul class="nav nav-pills"><li class="prev"><a href="#/gitflowwithgithub">Prev: Using GitFlow With GitHub</a></li><li class="next"><a href="#/examples">Next: Examples</a></li></ul></div><h1 id="versioning">Versioning</h1><h2 id="introduction">Introduction</h2><p>One of the topics that the <a href="http://nvie.com/posts/a-successful-git-branching-model/">original GitFlow article</a> doesn’t address at all is what scheme to adopt for your software’s version numbers.</p><p>But life is easier for <strong>everyone</strong> if version numbers <strong>mean the same thing</strong> to everyone who is working on a piece of software. QA can use these version numbers when reporting bugs and issues to ensure that the developers are on the same page, and that work is not being duplicated or overwritten.</p><h2 id="semantic_versioning">Semantic Versioning</h2><p><a href="http://semver.org/">Semantic versioning</a> is a very simple scheme built around the <strong>X.Y.Z-buildNo</strong> concept (for example <strong>2.6.0-2</strong> or <strong>2.6.0-SNAPSHOT20120501</strong> ):</p><ul><li>Increment <strong>Z</strong> when you fix something</li><li>Increment <strong>Y</strong> when you add a new feature</li><li>Increment <strong>X</strong> when you break backwards-compatibility or add major features</li><li>Use the <strong>buildNo</strong> to differentiate different builds off the same branch, and to differentiate between development, test and production builds.</li></ul><h3 id="possible_application_for_agency_work">Possible Application for Agency Work</h3><p>Because agencies have a fast turn-around for the majority of their projects, there is little time to output many solid API changes, and sometimes have only a single release iteration. Here is one possible usage of the versioning system in regards to an agency release:</p><ul><li><strong>Major Releases</strong> can refer to overall structure of the environment, being <strong>pre-release</strong> (for example <strong>v0.1.1</strong> ) prior to solidifying the folder structure and app technologies. Once this is solidified or updated, this should be incremented (for example <strong>v1.0.1</strong> ). This can be used to inform developers of a need to update their system environments to accomidate the change.</li><li><strong>Minor Releases</strong> can refer to the majority of major functionality added to the application.</li><li><strong>Other Releases</strong> can refer to the bugfixes and hotfixes made to correct an issue, rather than add functionailty.</li></ul><h2 id="version_numbers_and_gitflow_branches">Version Numbers And GitFlow Branches</h2><p>Here’s what to build from which branch.</p><ul><li><strong>Feature branches</strong> and the <strong>develop branch</strong> should always build <strong>snapshot</strong> versions (e.g. 2.6.0-SNAPSHOT201205012).</li><li><strong>Release branches</strong> and <strong>hotfix branches</strong> should always build <strong>release candidate</strong> versions (e.g. 2.6.0-0.rc1).</li><li>The <strong>master branch</strong> should always build unqualified versions - versions without build numbers (e.g. 2.6.0).</li></ul><p><span class="label label-important">Please remember:</span></p><ul><li>When you create a new branch, you need to <strong>manually update</strong> the software’s version number. The <strong>HubFlow tools</strong> cannot do this for you.</li><li>If you’re using <strong>RPM</strong>, you need to put the <strong>buildNo</strong> part of the version number into the <strong>release</strong> tag in your spec file (or add a <strong>release</strong> tag to the <strong>configuration</strong> section if you’re using Maven’s RPM plugin).</li></ul><h2 id="what_you_should_install_where">What You Should Install Where</h2><p>As a rule of thumb …</p><ul><li><strong>Snapshot versions</strong> should only be installed on <strong>dev boxes</strong> and <strong>integration environments</strong>. They shouldn’t be deployed to any of the <strong>dedicated test environments</strong>.</li><li><strong>Release candidates</strong> should be installed in the <strong>dedicated test environments</strong>. In an emergency, a release candidate can be installed into the <strong>production environment</strong>.</li><li><strong>Production releases</strong> can be installed anywhere - and they are the only kind of build that should be installed into the <strong>production environment</strong>.</li></ul></div>')
}]),App.controller("AboutCtrl",["$scope","$routeParams",function(e){e.awesomeThings=["Lorem","Ipsum","Dolar","Sit Amet"]}]),App.controller("MainCtrl",["$scope","$routeParams",function(e){e.awesomeThings=["jQuery","AngularJS","lessCSS","Karma"]}]);